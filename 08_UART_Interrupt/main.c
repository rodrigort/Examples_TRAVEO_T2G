/*******************************************************************************
* File Name:   main.c
*
* Description:
* Example 08 â€“ UART Interrupt-based Reception:
* This example demonstrates how to use the SCB UART of the TRAVEO T2G
* microcontroller to receive a fixed number of bytes asynchronously using
* interrupt-driven communication.
*
* The system waits for 5 bytes via UART (RX on P18.0) and echoes them back
* with a message prefix. A LED connected to P5.0 blinks briefly when data is received.
*
* - UART RX: P18.0
* - UART TX: P18.1
* - LED Activity Indicator: P5.0
*
* Related Document: See README.md
*
********************************************************************************
* Author: Rodrigo Teixeira
*******************************************************************************/

#include "cy_scb_common.h"          // Common definitions for SCB drivers
#include "cy_scb_uart.h"            // UART-specific functions from PDL
#include "cy_syslib.h"              // System-level functions (delays, assert, etc.)
#include "cybsp.h"                  // Board support package initialization
#include "cycfg_peripherals.h"      // Peripheral configuration generated by Device Configurator

#define RX_BUFFER_SIZE       5      // Number of bytes expected per reception
#define TX_BUFFER_SIZE       40     // Transmission buffer size

uint8_t rxBuffer[RX_BUFFER_SIZE];   // Buffer to store received UART data
uint8_t txBuffer[TX_BUFFER_SIZE] = "UART ready. Waiting for bytes...\r\n"; // Startup message

volatile bool rxFlag = false;       // Flag to indicate when a message has been fully received

cy_stc_scb_uart_context_t UART_0_context; // UART runtime context (required by PDL)

// UART interrupt configuration (for NVIC + multiplexer)
cy_stc_sysint_t UartIntrConfig =
{
    .intrSrc = ((NvicMux0_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | UART_0_IRQ), // NVIC source
    .intrPriority = (3U), // Interrupt priority
};

// UART event callback (triggered when RX transfer completes)
void UART_EventHandler(uint32_t event)
{
    if (event & CY_SCB_UART_RECEIVE_DONE_EVENT)
    {
        rxFlag = true; // Set flag to indicate reception is done
        Cy_SCB_UART_ClearRxFifo(UART_0_HW); // Clear any leftover RX data
    }
}

// UART interrupt handler (calls the PDL internal handler)
void UART_InterruptHandler(void)
{
    Cy_SCB_UART_Interrupt(UART_0_HW, &UART_0_context);
}

int main(void)
{
    // Initialize system, clocks, pins, and peripherals
    cy_rslt_t result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0); // Halt on failure
    }

    // Initialize UART with configuration from Device Configurator
    if (Cy_SCB_UART_Init(UART_0_HW, &UART_0_config, &UART_0_context) != CY_SCB_UART_SUCCESS)
    {
        while (1); // Halt if UART initialization fails
    }

    // Initialize interrupt configuration for UART
    Cy_SysInt_Init(&UartIntrConfig, UART_InterruptHandler);
    NVIC_EnableIRQ((IRQn_Type) NvicMux0_IRQn);

    // Enable UART hardware block
    Cy_SCB_UART_Enable(UART_0_HW);

    // Clear terminal screen and reset cursor
    Cy_SCB_UART_PutString(UART_0_HW, "\x1b[2J\x1b[;H");

    // Print UART header to terminal
    Cy_SCB_UART_PutString(UART_0_HW, "=========================================\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, "       Traveo T2G UART Interrupt Demo     \r\n");
    Cy_SCB_UART_PutString(UART_0_HW, "=========================================\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " UART Mode : Interrupt (asynchronous RX)\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " RX Pin    : P18.0\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " TX Pin    : P18.1\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " Baudrate  : 115200 bps (8N1)\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " Buffer    : Waits for 5 bytes per message\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, "-----------------------------------------\r\n");
    Cy_SCB_UART_PutString(UART_0_HW, " >> Send 5 bytes and receive feedback!\r\n\r\n");

    // Register callback to handle UART receive complete events
    Cy_SCB_UART_RegisterCallback(UART_0_HW, UART_EventHandler, &UART_0_context);

    // Enable RX interrupt when data is available in FIFO
    Cy_SCB_SetRxInterruptMask(UART_0_HW, CY_SCB_RX_INTR_NOT_EMPTY);

    // Enable TX interrupt when transmission is done
    Cy_SCB_SetTxInterruptMask(UART_0_HW, CY_SCB_TX_INTR_UART_DONE);

    // Enable global interrupts
    __enable_irq();

    // Start asynchronous receive for RX_BUFFER_SIZE bytes
    Cy_SCB_UART_Receive(UART_0_HW, rxBuffer, RX_BUFFER_SIZE, &UART_0_context);

    // Transmit startup message
    Cy_SCB_UART_Transmit(UART_0_HW, txBuffer, TX_BUFFER_SIZE, &UART_0_context);

    // Indicate system is ready (blink onboard LED)
    Cy_GPIO_Write(LED_1_PORT, LED_1_PIN, 0);
    Cy_SysLib_DelayCycles(200);
    Cy_GPIO_Write(LED_1_PORT, LED_1_PIN, 1);

    // Main loop
    for (;;)
    {
        // Check if reception is complete
        if (rxFlag)
        {
            rxFlag = false; // Reset flag

            Cy_GPIO_Write(LED_1_PORT, LED_1_PIN, 0); // Turn on LED (indicate reception)

            // Prepare response message
            memcpy(txBuffer, "Received bytes: ", 16); // Header
            memcpy(txBuffer + 16, rxBuffer, RX_BUFFER_SIZE); // Append data

            // Send response
            Cy_SCB_UART_Transmit(UART_0_HW, txBuffer, 16 + RX_BUFFER_SIZE, &UART_0_context);
            while (CY_SCB_UART_TRANSMIT_ACTIVE & Cy_SCB_UART_GetTransmitStatus(UART_0_HW, &UART_0_context));

            // Send line break
            Cy_SCB_UART_Transmit(UART_0_HW, (uint8_t *)"\r\n", 2, &UART_0_context);
            while (CY_SCB_UART_TRANSMIT_ACTIVE & Cy_SCB_UART_GetTransmitStatus(UART_0_HW, &UART_0_context));

            // Clear buffers
            memset(txBuffer, 0, TX_BUFFER_SIZE);
            memset(rxBuffer, 0, RX_BUFFER_SIZE);

             // Clear FIFO recption
             Cy_SCB_ClearRxFifo(UART_0_HW);

            // Restart reception
            Cy_SCB_UART_Receive(UART_0_HW, rxBuffer, RX_BUFFER_SIZE, &UART_0_context);

            Cy_GPIO_Write(LED_1_PORT, LED_1_PIN, 1); // Turn off LED
        }
    }
}
